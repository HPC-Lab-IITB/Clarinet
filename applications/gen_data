#!/usr/bin/python3
import os
import sys
import argparse

def main (argv) :
    # Command-line parsing
    parser = argparse.ArgumentParser (
              formatter_class=argparse.RawDescriptionHelpFormatter
            , description="Generates data for linear algebra tests. Call once for each variable.")

    parser.add_argument (
              '--vsz'
            , action="store"
            , type=int
            , dest='vec_size'
            , default=64
            , help="""Sizes of vector or dimension of matrix\n"""
            )
    parser.add_argument (
              '--vector'
            , action="store_false"
            , dest='is_matrix'
            , help="""Variable is a vector of size (vec_size). Do NOT use with --matrix\n"""
            )
    parser.add_argument (
              '--matrix'
            , action="store_true"
            , dest='is_matrix'
            , help="""Variable is a matrix of size (vec_size, vec_size). Do NOT use with --vector\n"""
            )
    parser.add_argument (
              '--transpose'
            , action="store_true"
            , dest='is_transpose'
            , help="""Generate transposed matrix. Only valid with --matrix.\n"""
            )
    parser.add_argument (
              '--no-transpose'
            , action="store_false"
            , dest='is_transpose'
            , help="""Generate non-transposed matrix. Only valid with --matrix.\n"""
            )
    parser.add_argument (
              '--var'
            , action="store"
            , dest='var_name'
            , required=True
            , help="""Name of variable being declared\n"""
            )
    parser.add_argument (
              '--type'
            , action="store"
            , dest='data_type'
            , default='f32'
            , help="""Data type used in the computation [f64, f32, p8, p16, p24, p32]\n"""
            )
    parser.add_argument (
              '--out'
            , action="store"
            , dest='out_file'
            , default='data.h'
            , help="""Output .h file which declares the data structures\n"""
            )

    args = parser.parse_args()

    if os.path.isfile (args.out_file) :
        # file already exists. Append to it
        try : outf = open (args.out_file, 'a')
        except :
            sys.stderr.write ("[ERROR]: Unable to open '%s' for appending\n" % args.out_file)
            sys.exit (1)
    else :
        # new file, create it and add the header, etc. 
        try : outf = open (args.out_file, 'w')
        except :
            sys.stderr.write ("[ERROR]: Unable to open '%s' for writing\n" % args.out_file)
            sys.exit (1)

        outf.write ("// --------\n")
        outf.write ("// This include file is auto-generated by the script gen_data. Do not edit.\n")
        outf.write ("// --------\n")
        outf.write ("// TYPE: %s. Vector/Matrix size: %d\n" % (args.data_type, args.vec_size))
        outf.write ("// --------\n\n")
        #outf.write ("#define VSZ %d\n\n" % args.vec_size)

    # The 'seed' data arrays which will be repeated to create the vectors of desired size
    # random float vals from farhad's GBLAS data generator
    seed_vals = {}
    seed_vals ['f64'] = [ '3.4050474167', '3.1847724915', '7.3107628822', '-5.6170530319', '-4.7297372818', '4.5974335670', '6.0904574394', '-3.0683014393', '4.1741681099', '-3.3324038982', '-7.1214756966', '2.7567198277', '-3.4179165363', '-9.2278394699', '8.9482812881', '-0.3960950971' ]

    # random p8 vals from farhad's GBLAS data generator
    seed_vals ['f32'] = [ '3.4050474167', '3.1847724915', '7.3107628822', '-5.6170530319', '-4.7297372818', '4.5974335670', '6.0904574394', '-3.0683014393', '4.1741681099', '-3.3324038982', '-7.1214756966', '2.7567198277', '-3.4179165363', '-9.2278394699', '8.9482812881', '-0.3960950971' ]

    # random p8 vals from farhad's GBLAS data generator
    seed_vals ['p8'] = [ '0x87', '0x8f', '0x8c', '0x69', '0x73', '0x78', '0x8e', '0xb1', '0xb2', '0x62', '0x87', '0x12', '0x9e', '0x76', '0x9e', '0xef' ]

    # random p16 vals from farhad's GBLAS data generator
    seed_vals ['p16'] = [ '0x96ac', '0x9f09', '0x9c02', '0x5937', '0x62b1', '0x6880', '0x9e74', '0xb8ae', '0xb916', '0x51f4', '0x96c3', '0x2262', '0xadce', '0x6676', '0xadcd', '0xdec6' ]

    # random p24 vals from farhad's GBLAS data generator
    seed_vals ['p24'] = [ '0xa6ac1500', '0xaf08ad00', '0xac018400', '0x4c9b9500', '0x52b13500', '0x58803d00', '0xae745400', '0xbc56fb00', '0xbc8b1b00', '0x48fa0500', '0xa6c30000', '0x31314000', '0xb6e6d000', '0x5675aa00', '0xb6e64d00', '0xcf62f600' ]

    # random p32 vals from farhad's GBLAS data generator
    seed_vals ['p32'] = [ '0xa6ac1570', '0xaf08ad60', '0xac0183f0', '0x4c9b9540', '0x52b13500', '0x58803d70', '0xae745430', '0xbc56fb50', '0xbc8b1aa0', '0x48fa0540', '0xa6c2ffa0', '0x31313ff0', '0xb6e6cfe0', '0x5675aa10', '0xb6e64d30', '0xcf62f5a0' ]

    # number of times to repeat the seed-array contents to create the operand arrays of desired size
    repetition = args.vec_size // 16

    operand_decl = 'static '
    if (args.data_type == 'f64') :
        # generate 64-bit FP arrays
        operand_decl = operand_decl + 'double '

    elif (args.data_type == 'f32') :
        # generate 32-bit FP arrays
        operand_decl = operand_decl + 'float '

    elif (args.data_type == 'p8') :
        # generate 8-bit posit arrays
        operand_decl = operand_decl + 'unsigned char '

    elif (args.data_type == 'p16') :
        # generate 16-bit posit arrays
        operand_decl = operand_decl + 'unsigned short '

    elif ((args.data_type == 'p24') or (args.data_type == 'p32')):
        # generate 24-bit/32-bit posit arrays
        operand_decl = operand_decl + 'unsigned int '

    else :
        sys.stderr.write ("[ERROR]: Unrecognized data type: '%s'. Look at usage.\n" % args.data_type)
        sys.exit (1)

    operand_decl = operand_decl + args.var_name
    if args.is_matrix : operand_decl = operand_decl + ' [VSZ][VSZ]'
    else              : operand_decl = operand_decl + ' [VSZ]'

    # construct the contents of the operand array in the declaration
    operand_array = fn_compose_operand_array (repetition, seed_vals, args.data_type)

    # for a matrix, compose operand_arrays into operand_val
    if args.is_matrix :
        if args.is_transpose : operand_val = fn_compose_operand_matrix (args.vec_size, operand_array)
        else : operand_val = fn_compose_transposed_matrix (args.vec_size, operand_array)

    # for a vector use the operand_array as operand_val
    else : operand_val = operand_array

    # write out the declaration into the header file
    outf.write ("%s = %s;\n\n" % (operand_decl, operand_val))

    outf.close ()

    return 0

# Compose seed arrays into an operand array
def fn_compose_operand_matrix (repetition, operand_array) :
    # split array into constituent elements
    seed_array    = operand_array.strip ('{')
    seed_array    = seed_array.strip ('}')
    seed_array    = seed_array.strip ()
    seed_values   = seed_array.split (',')

    operand_val = "{ "
    first_array = True
    for val in seed_values :
        first_val = True
        # array delimiters
        if first_array :
            operand_val = operand_val + "{" 
            first_array = False
        else :
            operand_val = operand_val + ",{" 

        # value delimiters
        for rep in range (repetition) :
            if first_val :
                operand_val = operand_val + val
                first_val = False
            else :
                operand_val = operand_val + "," + val
        operand_val = operand_val + "}" 

    operand_val = operand_val + " }"
    return operand_val

# Compose seed arrays into an operand array
def fn_compose_transposed_matrix (repetition, operand_array) :
    operand_val = "{ "
    first_array = True
    for rep in range (repetition) :
        if first_array :
            operand_val = operand_val + operand_array
            first_array = False
        else :
            operand_val = operand_val + "," + operand_array
    operand_val = operand_val + " }"
    return operand_val

# Compose seed values into an operand array
def fn_compose_operand_array (repetition, seed_vals, data_type) :
    operand_val = "{ "
    first_val = True
    for rep in range (repetition) :
        for val in seed_vals [data_type] :
            if first_val :
                operand_val = operand_val + val 
                first_val = False
            else : operand_val = operand_val + ',' + val
    operand_val = operand_val + ' }'
    return operand_val

# ================================================================
# For non-interactive invocations, call main() and use its return value
# as the exit code.
if __name__ == '__main__':
  sys.exit (main (sys.argv))
