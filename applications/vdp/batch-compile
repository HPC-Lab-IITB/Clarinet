#!/usr/bin/python3
import os
import sys
import shutil
import subprocess
import logging
import datetime

"""
Compiles all the different variants of the VDP program, and then runs each of them in simulations.
Ensure that you the RV tools in your path, and the verilator simulator executables are already created.
"""

CWD = os.getcwd ()
HW_BDIR = os.path.join (CWD, '..', '..', 'builds')

#------------------------
"""
Create a logger
"""
def fn_createLogger (debug, thisScript):
    # Create a journal file to log all activity from this run
    now = datetime.datetime.now ()
    journalFName = thisScript + '-' + now.strftime("%Y%m%d_%H%M") + ".jou"
    journalPath  = os.path.join (CWD, journalFName)
    if debug == True :
        logging.basicConfig (
                  filename=journalPath
                , filemode='w'
                , level=logging.DEBUG
                , format='[%(asctime)s][%(levelname)5s] %(message)s'
                , datefmt='%H:%M:%S')
    else :
        logging.basicConfig (
                  filename=journalPath
                , filemode='w'
                , level=logging.INFO
                , format='[%(asctime)s][%(levelname)5s] %(message)s'
                , datefmt='%H:%M:%S')

    # Define a Handler which writes INFO messages or higher to the sys.stderr
    console = logging.StreamHandler()
    console.setLevel(logging.INFO)

    # set a format for console logs (simplified - no time-stamp)
    formatter = logging.Formatter('[%(levelname)5s]: %(message)s')

    # tell the handler to use this format
    console.setFormatter(formatter)

    # Add the handler to the root logger
    logging.getLogger('').addHandler(console)
    return
    

def main (argv) :
    fn_createLogger (True, 'batch-compile') 
    types = ['FLOAT', 'FLOAT_POSIT', 'POSIT']
    reps  = [8, 16, 32, 64, 128, 256]
    files_to_move = ['vdp', 'vdp.dump']

    makeLogFile = os.path.join(CWD, "make.log")
    try : makeLog = open (makeLogFile, "w")
    except :
        logging.error ("Unable to open '%s' for writing", makeLogFile)
        sys.exit (1)

    simLogFile = os.path.join(CWD, "sim.log")
    try : simLog = open (simLogFile, "w")
    except :
        logging.error ("Unable to open '%s' for writing", simLogFile)
        sys.exit (1)

    main_val = 'MAIN=vdp'
    for type in types :
        type_val = 'TYPE='+type

        if type == 'POSIT' : pwidths = [8, 16, 24, 32]
        else : pwidths = [8]

        for pw in pwidths :
            pw_val = 'PWIDTH=PWIDTH_'+str(pw)
            for rep in reps :
                rep_val = 'REP='+str(rep)
                logging.info ("make %s %s %s %s all", main_val, type_val, rep_val, pw_val)
                makeID = subprocess.Popen (
                                [     "/usr/bin/make"
                                    , main_val
                                    , type_val
                                    , rep_val
                                    , pw_val
                                    , 'all'
                                ]
                            , stdout=makeLog
                            , stderr=subprocess.STDOUT
                            , cwd=CWD)
                makeID.wait()

                if makeID.returncode == 0 :
                    logging.info ("App build: Success")
                    # Name the executable and dump as per configuration
                    for f in files_to_move :
                        if type == 'POSIT' : prefix = type + '-' + str(pw) + '.' + str(rep) 
                        else : prefix = type + '.' + str(rep)
                        if f == 'vdp' :
                            new_file = prefix + '.' + 'vdp.elf'
                            test_elf_name = new_file
                        else :
                            new_file = prefix + '.' + f

                        shutil.move (os.path.join (CWD, f), os.path.join (CWD, new_file))
                        logging.debug ("mv %s %s", os.path.join (CWD, f), os.path.join (CWD, new_file))

                    # Clean up
                    makeID = subprocess.Popen (
                                    [     "/usr/bin/make"
                                        , main_val
                                        , type_val
                                        , rep_val
                                        , 'clean'
                                    ]
                                , stdout=makeLog
                                , stderr=subprocess.STDOUT
                                , cwd=CWD)
                    makeID.wait()

                    # Run the simulation
                    if type == 'FLOAT' : hw_dir_name = 'RV32ACFIMSU_verilator'                # do not include Posit HW for a pure FP run
                    else :               hw_dir_name = 'RV32ACFIMSU_P'+str(pw)+'_verilator'
                    hw_dir_path = os.path.join (HW_BDIR, hw_dir_name)
                    test_path = os.path.join (CWD, test_elf_name)
                    example_val = 'EXAMPLE='+test_path
                    logging.info ("Simulating %s on %s", test_elf_name, hw_dir_name)
                    simLog.write ("-------- Simulating %s on %s --------\n" %(test_elf_name, hw_dir_name))

                    simID = subprocess.Popen (
                              [     '/usr/bin/make'
                                  , '-f'
                                  , os.path.join (hw_dir_path, 'Makefile')
                                  , 'run_example'
                                  , example_val
                                  ]
                            , stdout=simLog
                            , stderr=subprocess.STDOUT
                            , cwd = hw_dir_path
                            )
                    simID.wait ()
                    simLog.write ("\n\n")

                    # Save the vcd dumps for further processing
                    if type == 'POSIT' : vcd_saved_dir = type+'-'+str(pw)+'.'+str(rep)+'.vcd'
                    else :               vcd_saved_dir = type+'.'+str(rep)+'.vcd'
                    shutil.copytree (os.path.join (hw_dir_path, 'vcd'), os.path.join (CWD, vcd_saved_dir))
                    shutil.rmtree (os.path.join (hw_dir_path, 'vcd'))
                    logging.info ("Saving VCD files to %s", os.path.join (CWD, vcd_saved_dir))

                else : logging.error ("App build: Failure")

    makeLog.close ()
    simLog.close ()
    return 0

# ================================================================
# For non-interactive invocations, call main() and use its return value
# as the exit code.
if __name__ == '__main__':
  sys.exit (main (sys.argv))
